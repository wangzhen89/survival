<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>第 9 章 区间删失生存数据 | 医学研究中的生存数据建模</title>
<meta name="author" content="Wang Zhen">
<meta name="description" content="在许多响应变量为生存时间的研究中，感兴趣事件的确切时间尚不清楚。相反，事件认为是在特定的时间区间内发生的。这种形式的数据称为分组或区间删失 (grouped or interval-censored)...">
<meta name="generator" content="bookdown 0.38 with bs4_book()">
<meta property="og:title" content="第 9 章 区间删失生存数据 | 医学研究中的生存数据建模">
<meta property="og:type" content="book">
<meta property="og:description" content="在许多响应变量为生存时间的研究中，感兴趣事件的确切时间尚不清楚。相反，事件认为是在特定的时间区间内发生的。这种形式的数据称为分组或区间删失 (grouped or interval-censored)...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第 9 章 区间删失生存数据 | 医学研究中的生存数据建模">
<meta name="twitter:description" content="在许多响应变量为生存时间的研究中，感兴趣事件的确切时间尚不清楚。相反，事件认为是在特定的时间区间内发生的。这种形式的数据称为分组或区间删失 (grouped or interval-censored)...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.7.0/transition.js"></script><script src="libs/bs3compat-0.7.0/tabs.js"></script><script src="libs/bs3compat-0.7.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script>
    /* ========================================================================
     * Bootstrap: transition.js v3.3.7
     * http://getbootstrap.com/javascript/#transitions
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */


    +function ($) {
      'use strict';

      // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
      // ============================================================

      function transitionEnd() {
        var el = document.createElement('bootstrap')

        var transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        }

        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return { end: transEndEventNames[name] }
          }
        }

        return false // explicit for ie8 (  ._.)
      }

      // http://blog.alexmaccaw.com/css-transitions
      $.fn.emulateTransitionEnd = function (duration) {
        var called = false
        var $el = this
        $(this).one('bsTransitionEnd', function () { called = true })
        var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
        setTimeout(callback, duration)
        return this
      }

      $(function () {
        $.support.transition = transitionEnd()

        if (!$.support.transition) return

        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function (e) {
            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
          }
        }
      })

    }(jQuery);
    </script><script>
    /* ========================================================================
     * Bootstrap: collapse.js v3.3.7
     * http://getbootstrap.com/javascript/#collapse
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    /* jshint latedef: false */

    +function ($) {
      'use strict';

      // COLLAPSE PUBLIC CLASS DEFINITION
      // ================================

      var Collapse = function (element, options) {
        this.$element      = $(element)
        this.options       = $.extend({}, Collapse.DEFAULTS, options)
        this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                               '[data-toggle="collapse"][data-target="#' + element.id + '"]')
        this.transitioning = null

        if (this.options.parent) {
          this.$parent = this.getParent()
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger)
        }

        if (this.options.toggle) this.toggle()
      }

      Collapse.VERSION  = '3.3.7'

      Collapse.TRANSITION_DURATION = 350

      Collapse.DEFAULTS = {
        toggle: true
      }

      Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass('width')
        return hasWidth ? 'width' : 'height'
      }

      Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass('in')) return

        var activesData
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

        if (actives && actives.length) {
          activesData = actives.data('bs.collapse')
          if (activesData && activesData.transitioning) return
        }

        var startEvent = $.Event('show.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return

        if (actives && actives.length) {
          Plugin.call(actives, 'hide')
          activesData || actives.data('bs.collapse', null)
        }

        var dimension = this.dimension()

        this.$element
          .removeClass('collapse')
          .addClass('collapsing')[dimension](0)
          .attr('aria-expanded', true)

        this.$trigger
          .removeClass('collapsed')
          .attr('aria-expanded', true)

        this.transitioning = 1

        var complete = function () {
          this.$element
            .removeClass('collapsing')
            .addClass('collapse in')[dimension]('')
          this.transitioning = 0
          this.$element
            .trigger('shown.bs.collapse')
        }

        if (!$.support.transition) return complete.call(this)

        var scrollSize = $.camelCase(['scroll', dimension].join('-'))

        this.$element
          .one('bsTransitionEnd', $.proxy(complete, this))
          .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
      }

      Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass('in')) return

        var startEvent = $.Event('hide.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return

        var dimension = this.dimension()

        this.$element[dimension](this.$element[dimension]())[0].offsetHeight

        this.$element
          .addClass('collapsing')
          .removeClass('collapse in')
          .attr('aria-expanded', false)

        this.$trigger
          .addClass('collapsed')
          .attr('aria-expanded', false)

        this.transitioning = 1

        var complete = function () {
          this.transitioning = 0
          this.$element
            .removeClass('collapsing')
            .addClass('collapse')
            .trigger('hidden.bs.collapse')
        }

        if (!$.support.transition) return complete.call(this)

        this.$element
          [dimension](0)
          .one('bsTransitionEnd', $.proxy(complete, this))
          .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
      }

      Collapse.prototype.toggle = function () {
        this[this.$element.hasClass('in') ? 'hide' : 'show']()
      }

      Collapse.prototype.getParent = function () {
        return $(this.options.parent)
          .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
          .each($.proxy(function (i, element) {
            var $element = $(element)
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
          }, this))
          .end()
      }

      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass('in')

        $element.attr('aria-expanded', isOpen)
        $trigger
          .toggleClass('collapsed', !isOpen)
          .attr('aria-expanded', isOpen)
      }

      function getTargetFromTrigger($trigger) {
        var href
        var target = $trigger.attr('data-target')
          || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

        return $(target)
      }


      // COLLAPSE PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.collapse')
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
          if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }

      var old = $.fn.collapse

      $.fn.collapse             = Plugin
      $.fn.collapse.Constructor = Collapse


      // COLLAPSE NO CONFLICT
      // ====================

      $.fn.collapse.noConflict = function () {
        $.fn.collapse = old
        return this
      }


      // COLLAPSE DATA-API
      // =================

      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
        var $this   = $(this)

        if (!$this.attr('data-target')) e.preventDefault()

        var $target = getTargetFromTrigger($this)
        var data    = $target.data('bs.collapse')
        var option  = data ? 'toggle' : $this.data()

        Plugin.call($target, option)
      })

    }(jQuery);
    </script><script>
    window.initializeCodeFolding = function(show) {

      // handlers for show-all and hide all
      $("#rmd-show-all-code").click(function() {
        $('div.r-code-collapse').each(function() {
          $(this).collapse('show');
        });
      });
      $("#rmd-hide-all-code").click(function() {
        $('div.r-code-collapse').each(function() {
          $(this).collapse('hide');
        });
      });

      // index for unique code element ids
      var currentIndex = 1;

      // select all R code blocks
      var rCodeBlocks = $('pre.sourceCode, pre.r, pre.python, pre.bash, pre.sql, pre.cpp, pre.stan, pre.js');
      rCodeBlocks.each(function() {

        // create a collapsable div to wrap the code in
        var div = $('<div class="collapse r-code-collapse"></div>');
        if (show)
          div.addClass('in');
        var id = 'rcode-643E0F36' + currentIndex++;
        div.attr('id', id);
        $(this).before(div);
        $(this).detach().appendTo(div);

        // add a show code button right above
        var showCodeText = $('<span>' + (show ? 'Hide' : 'Code') + '</span>');
        var showCodeButton = $('<button type="button" class="btn btn-default btn-xs code-folding-btn pull-right"></button>');
        showCodeButton.append(showCodeText);
        showCodeButton
            .attr('data-toggle', 'collapse')
            .attr('data-target', '#' + id)
            .attr('aria-expanded', show)
            .attr('aria-controls', id);

        var buttonRow = $('<div class="row"></div>');
        var buttonCol = $('<div class="col-md-12"></div>');

        buttonCol.append(showCodeButton);
        buttonRow.append(buttonCol);

        div.before(buttonRow);

        // update state of button on show/hide
        div.on('hidden.bs.collapse', function () {
          showCodeText.text('Code');
        });
        div.on('show.bs.collapse', function () {
          showCodeText.text('Hide');
        });
      });

    }
    </script><script>
    /* ========================================================================
     * Bootstrap: dropdown.js v3.3.7
     * http://getbootstrap.com/javascript/#dropdowns
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */


    +function ($) {
      'use strict';

      // DROPDOWN CLASS DEFINITION
      // =========================

      var backdrop = '.dropdown-backdrop'
      var toggle   = '[data-toggle="dropdown"]'
      var Dropdown = function (element) {
        $(element).on('click.bs.dropdown', this.toggle)
      }

      Dropdown.VERSION = '3.3.7'

      function getParent($this) {
        var selector = $this.attr('data-target')

        if (!selector) {
          selector = $this.attr('href')
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }

        var $parent = selector && $(selector)

        return $parent && $parent.length ? $parent : $this.parent()
      }

      function clearMenus(e) {
        if (e && e.which === 3) return
        $(backdrop).remove()
        $(toggle).each(function () {
          var $this         = $(this)
          var $parent       = getParent($this)
          var relatedTarget = { relatedTarget: this }

          if (!$parent.hasClass('open')) return

          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

          if (e.isDefaultPrevented()) return

          $this.attr('aria-expanded', 'false')
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
        })
      }

      Dropdown.prototype.toggle = function (e) {
        var $this = $(this)

        if ($this.is('.disabled, :disabled')) return

        var $parent  = getParent($this)
        var isActive = $parent.hasClass('open')

        clearMenus()

        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            // if mobile we use a backdrop because click events don't delegate
            $(document.createElement('div'))
              .addClass('dropdown-backdrop')
              .insertAfter($(this))
              .on('click', clearMenus)
          }

          var relatedTarget = { relatedTarget: this }
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

          if (e.isDefaultPrevented()) return

          $this
            .trigger('focus')
            .attr('aria-expanded', 'true')

          $parent
            .toggleClass('open')
            .trigger($.Event('shown.bs.dropdown', relatedTarget))
        }

        return false
      }

      Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

        var $this = $(this)

        e.preventDefault()
        e.stopPropagation()

        if ($this.is('.disabled, :disabled')) return

        var $parent  = getParent($this)
        var isActive = $parent.hasClass('open')

        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27) $parent.find(toggle).trigger('focus')
          return $this.trigger('click')
        }

        var desc = ' li:not(.disabled):visible a'
        var $items = $parent.find('.dropdown-menu' + desc)

        if (!$items.length) return

        var index = $items.index(e.target)

        if (e.which == 38 && index > 0)                 index--         // up
        if (e.which == 40 && index < $items.length - 1) index++         // down
        if (!~index)                                    index = 0

        $items.eq(index).trigger('focus')
      }


      // DROPDOWN PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this)
          var data  = $this.data('bs.dropdown')

          if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
          if (typeof option == 'string') data[option].call($this)
        })
      }

      var old = $.fn.dropdown

      $.fn.dropdown             = Plugin
      $.fn.dropdown.Constructor = Dropdown


      // DROPDOWN NO CONFLICT
      // ====================

      $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old
        return this
      }


      // APPLY TO STANDARD DROPDOWN ELEMENTS
      // ===================================

      $(document)
        .on('click.bs.dropdown.data-api', clearMenus)
        .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
        .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
        .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

    }(jQuery);
    </script><style type="text/css">
    .code-folding-btn { margin-bottom: 4px; }
    .row { display: flex; }
    .collapse { display: none; }
    .in { display:block }
    .pull-right > .dropdown-menu {
        right: 0;
        left: auto;
    }
    .open > .dropdown-menu {
        display: block;
    }
    .dropdown-menu {
        position: absolute;
        top: 100%;
        left: 0;
        z-index: 1000;
        display: none;
        float: left;
        min-width: 160px;
        padding: 5px 0;
        margin: 2px 0 0;
        font-size: 14px;
        text-align: left;
        list-style: none;
        background-color: #fff;
        -webkit-background-clip: padding-box;
        background-clip: padding-box;
        border: 1px solid #ccc;
        border: 1px solid rgba(0,0,0,.15);
        border-radius: 4px;
        -webkit-box-shadow: 0 6px 12px rgba(0,0,0,.175);
        box-shadow: 0 6px 12px rgba(0,0,0,.175);
    }
    </style>
<script>
    $(document).ready(function () {
      window.initializeCodeFolding("show" === "show");
    });
    </script><script>
    document.write('<div class="btn-group pull-right" style="position: absolute; top: 20%; right: 2%; z-index: 200"><button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true" data-_extension-text-contrast=""><span>Code</span> <span class="caret"></span></button><ul class="dropdown-menu" style="min-width: 50px;"><li><a id="rmd-show-all-code" href="#">Show All Code</a></li><li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li></ul></div>')
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">医学研究中的生存数据建模</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">前言</a></li>
<li><a class="" href="%E4%BD%9C%E8%80%85%E4%BB%8B%E7%BB%8D.html">作者介绍</a></li>
<li><a class="" href="%E7%9B%AE%E5%BD%95.html">目录</a></li>
<li class="book-part">正文</li>
<li><a class="" href="chap1.html"><span class="header-section-number">1</span> 生存分析</a></li>
<li><a class="" href="chap2.html"><span class="header-section-number">2</span> 一些非参数程序</a></li>
<li><a class="" href="chap3.html"><span class="header-section-number">3</span> Cox 回归模型</a></li>
<li><a class="" href="cox-%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.html">►Cox 回归模型</a></li>
<li><a class="" href="chap4.html"><span class="header-section-number">4</span> Cox 回归模型的模型检查</a></li>
<li><a class="" href="chap5.html"><span class="header-section-number">5</span> 参数回归模型</a></li>
<li><a class="" href="%E5%8F%82%E6%95%B0%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.html">►参数回归模型</a></li>
<li><a class="" href="chap6.html"><span class="header-section-number">6</span> 灵活的参数模型</a></li>
<li><a class="" href="chap7.html"><span class="header-section-number">7</span> 参数模型的模型检查</a></li>
<li><a class="" href="chap8.html"><span class="header-section-number">8</span> 时依变量</a></li>
<li><a class="active" href="chap9.html"><span class="header-section-number">9</span> 区间删失生存数据</a></li>
<li><a class="" href="chap10.html"><span class="header-section-number">10</span> 脆弱模型</a></li>
<li><a class="" href="chap11.html"><span class="header-section-number">11</span> 非比例风险和机构的比较</a></li>
<li><a class="" href="chap12.html"><span class="header-section-number">12</span> 竞争风险</a></li>
<li><a class="" href="chap13.html"><span class="header-section-number">13</span> 多次事件和事件史分析</a></li>
<li><a class="" href="chap14.html"><span class="header-section-number">14</span> 相依删失</a></li>
<li><a class="" href="chap15.html"><span class="header-section-number">15</span> 生存研究的样本量要求</a></li>
<li><a class="" href="chap16.html"><span class="header-section-number">16</span> 贝叶斯生存分析</a></li>
<li><a class="" href="chap17.html"><span class="header-section-number">17</span> 使用 R 进行生存分析</a></li>
<li class="book-part">附录</li>
<li><a class="" href="A.html"><span class="header-section-number">A</span> 最大似然估计</a></li>
<li><a class="" href="B.html"><span class="header-section-number">B</span> 额外数据集</a></li>
<li class="book-part">—</li>
<li><a class="" href="bib.html">参考书目</a></li>
<li><a class="" href="exm.html">示例索引</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="chap9" class="section level1" number="9">
<h1>
<span class="header-section-number">第 9 章</span> 区间删失生存数据<a class="anchor" aria-label="anchor" href="#chap9"><i class="fas fa-link"></i></a>
</h1>
<p>在许多响应变量为生存时间的研究中，感兴趣事件的确切时间尚不清楚。相反，事件认为是在特定的时间区间内发生的。这种形式的数据称为分组或<strong>区间删失</strong> (grouped or interval-censored) 生存数据，通常出现在存在非致命终点的研究中。例如，定期看牙医的儿童恒牙萌出的时间、连续随访之间癌症复发的时间，以及定期进行血液检查的艾滋病毒感染者发展为艾滋病的时间。事实上，大多数生存分析都是基于区间删失数据，因为生存时间通常视为最近的一天、一周或一个月。本章将描述并说明区间删失数据的总结和建模方法。</p>
<div id="sec9-1" class="section level2" number="9.1">
<h2>
<span class="header-section-number">9.1</span> 区间删失<a class="anchor" aria-label="anchor" href="#sec9-1"><i class="fas fa-link"></i></a>
</h2>
<p>删失在事件时间数据中广泛存在，当研究的终点时间不明确时就会出现。这本书包含了许多右删失的例子，其中一些事件实际的时间比观测的要长。左删失发生的频率要低得多，此时已知事件的实际时间小于观测时间。当仅知道事件在某个时间区间内发生时，事件发生的时间称为区间删失。</p>
<p>为了说明这些不同类型的删失，请考虑一项针对心脏病发生年龄的研究，其中招募了 60 岁以上的个体并在一段时间内定期检查。在研究结束时，有些个体可能没有患上心脏病，或者可能死于其他原因。这些个体的事件时间是右删失的。另一方面，当首次对被招募的个体进行检查时，可能会发现一些人已经患上了心脏病。那么对这些个体的事件时间是左删失的，因为人们只知道他们的心脏病是在初次筛查之前的某个时间发展得来的。在其他情况下，有些个体经过检查未发现没有心脏病，但在下一次检查时却发现了该病。对他们来说，发病时间在两次检查之间，他们的发病时间是区间删失的。</p>
<p>右删失和左删失实际上是区间删失的特殊情况。考虑一个事件时间 <span class="math inline">\(t\)</span>，它只发生在从 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(U\)</span> 的时间区间内，其中 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(U\)</span> 分别指下限和上限。这个区间将表示为 <span class="math inline">\((L, U]\)</span>，表示 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(L&lt;t\leqslant U\)</span>。该区间在下限处是开的，在上限处是闭的，以消除事件时间所在区间的歧义。例如，如果时间以天为单位测量，并且已知事件发生在 5 到 10 天之间，则区间 <span class="math inline">\((5,10]\)</span> 表示事件发生在第 5 天之后，但发生在第 10 天或之前。另一方面，发生在第 5 天或之前的事件将处于上限为 5 天的时间区间内。</p>
<p>在这种表示法中，如果事件时间 <span class="math inline">\(t\)</span> 是精确已知的，则 <span class="math inline">\(L=U\)</span>。如果 <span class="math inline">\(L=t\)</span> 且 <span class="math inline">\(U=\infty\)</span>，因此事件时间仅已知是超过 <span class="math inline">\(t\)</span> 的，则事件时间是右删失的。右删失事件时间区间的上限也可用星号（*）表示。如果 <span class="math inline">\(L=0\)</span> 且 <span class="math inline">\(U=t\)</span>，则已知事件在时间 <span class="math inline">\(t\)</span> 之前已经发生，因此 <span class="math inline">\(t\)</span> 是左删失的。一组时间事件观测数据可能包含实际时间以及右删失、左删失和区间删失时间的混合。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-1" class="example"><strong>示例 9.1  (溃疡复发) </strong></span><br></p>
<p>在一项双盲临床试验中，研究人员比较了两种治疗方案对首次治疗后溃疡复发的抑制作用。患者被随机分配接受标记为 A 和 B 的两种治疗方案中的一种。为患者安排了诊所以定期就诊，并在随机分配后的 6 个月和 12 个月进行内窥镜检查。内窥镜检查阳性结果表明自上次阴性结果以来溃疡已复发。因此，获得了溃疡是否在 0 至 6 个月或 6 至 12 个月的区间内复发的信息。此外，一些患者在预定就诊之间出现复发症状。这些患者在这些时候进行了内窥镜检查，以检测是否确实发生了复发。</p>
<p>在试验入组时，除了治疗组（A 或 B），还记录了每位患者的年龄（以年为单位）和确诊疾病的持续时间（1 = 小于五年，2 = 大于或等于五年）。数据集中有两个与溃疡检测相关的变量，即最后一次就诊的时间（以月为单位）和当时的内窥镜检查结果（1 = 未检测到溃疡，2 = 检测到溃疡）。那些时间不等于 6 或 12 个月的人在预定就诊之间出现了症状。这项研究本身是跨国的，Whitehead (1989) 提供了全套数据。本例将使用比利时的数据，相关数据如表 9.1 所示。</p>
<details><summary><font color="#8B2232">表 9.1</font>
</summary><img src="figure/table%209.1.png#center" style="width:80.0%"></details><p><br>
在对这项研究的数据进行建模时，疾病的持续时间由一个指示变量 <span class="math inline">\(Duration\)</span> 表示，当持续时间小于五年时，该变量为零，否则为一。治疗效应由变量 <span class="math inline">\(Treat\)</span> 表示，如果个体接受治疗 A，则该变量取值为零，如果接受治疗 B，则取值为一。患者的年龄反映在连续变量 <span class="math inline">\(Age\)</span> 中。</p>
<p>表 9.1 最后两列中最后一次就诊的时间和结果的数据可以转换为溃疡复发的区间删失时间。表 9.2 显示了由最近内窥镜检查的时间值和结果的各种组合产生的区间删失时间。具有无限上限的事件时间是右删失的。在以这种方式转换数据之后，它们现在是区间删失数据的形式。</p>
<p>分析这类数据的一种方法是仅关注检测到的复发时间。然而，这些数据是两种复发的混合：预定的筛查时间检测到的复发（称为<strong>筛查检出的复发</strong>，screen-detected recurrences）、出现症状后诊断出的复发（称为<strong>区间检出的复发</strong>，interval-detected recurrences）。这使得解释分析结果变得困难。为了说明这个问题，假设本例中的两种治疗方法对复发时间具有完全相同的效果，但新的治疗方法抑制了症状。接受新治疗的患者的溃疡复发往往比接受标准治疗的患者的溃疡复发更晚被检测到。那么，在接受标准治疗的患者中，区间检测到的复发将更快地被识别出来，并且这组患者的复发时间将更短。这将表明新治疗优于标准治疗，但这是错误的结论。</p>
</div>
</div>
<p>在某些情况下，忽略区间删失并在标准分析中使用时间区间的上限或下限可能是合理的。当时间区间相对于研究持续时间相当小时，这可能是可行的。调整区间删失数据以便进行标准分析的另一种方法是在每个观测的时间区间内插补 (imputat) 一个值。为此，可以使用区间的中点或更复杂的多重插补法 (multiple imputation methods). 然而，这些方法可能会得到有偏的推断，应优选专门为分析区间删失数据而开发的方法。</p>
<div id="sec9-1-1" class="section level3" number="9.1.1">
<h3>
<span class="header-section-number">9.1.1</span> 当前状态数据<a class="anchor" aria-label="anchor" href="#sec9-1-1"><i class="fas fa-link"></i></a>
</h3>
<p>当只有一个观测时间，并且只能知道研究中每个个体在该时间之前是否经历过某种事件时，就出现了区间删失数据的特例。这种类型的数据称为<strong>当前状态数据</strong> (current status data). 已经历过该事件的个体有左删失事件时间，而尚未发生该事件的个体有右删失时间。因此，所得数据集中的所有观测要么是左删失，要么是右删失。使用本章描述的分析方法，可以获得相应生存函数的估计和相关的总结统计量。此外，用于分析区间删失数据的建模方法可用于识别可能与当前状态数据中事件时间相关的因素。</p>
<p>为了说明当前状态数据，考虑一项致癌性研究，在该研究中，实验室动物暴露于某种化学物质中，并且肿瘤发生的时间是令人感兴趣的。这些动物在暴露 30 天后被处死，随后进行检查以确定是否存在肿瘤。发现患有肿瘤的动物的左删失事件时间为30天，而没有肿瘤的动物的右删失事件时间为30天。那么可以从生存函数估计中找到肿瘤发展时间分布的百分位数。同样，在确定初潮年龄（月经开始时间）的流行病学研究中，记录了参与研究的女性是否发生月经初潮的数据。由此得出的数据可以用月经初潮年龄的中位数进行总结，并且可以评估月经初潮年龄对社会经济地位等因素的相关性。</p>
</div>
</div>
<div id="sec9-2" class="section level2" number="9.2">
<h2>
<span class="header-section-number">9.2</span> 估计生存函数<a class="anchor" aria-label="anchor" href="#sec9-2"><i class="fas fa-link"></i></a>
</h2>
<p>我们在第 <a href="chap2.html#chap2">2</a> 章看到了如何使用 Kaplan-Meier 或 Nelson-Aalen 估计来估计右删失数据的生存函数。它们是阶跃函数，其中生存函数估计在相邻事件时间之间是恒定的，并仅在事件时间处发生变化。当数据集包括区间删失事件时间时，生存函数估计也是一个阶跃函数，但该估计在特定时间区间（称为 <strong>Turnbull 区间</strong>）内是未定义的。</p>
<p>为了确定 Turnbull 区间，需要将区间删失事件时间的所有下边界和上边界按升序排列，并根据它们是时间区间的下限还是上限分别标记为 <span class="math inline">\(L\)</span> 或 <span class="math inline">\(U\)</span>。然后确定以 <span class="math inline">\(L\)</span> 为下限、以 <span class="math inline">\(U\)</span> 为上限的区间，这些就是 Turnbull 区间，它们之间不会有其他区间删失时间的下限或上限值。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-2" class="example"><strong>示例 9.2  (人造区间删失数据) </strong></span><br></p>
<p>为了说明 Turnbull 区间的构造，假设有五个个体的事件时间：一个左删失时间、一个右删失事件时间和三个区间删失时间。区间删失格式的观测结果如下：</p>
<p><span class="math display">\[\begin{aligned}(3,6]\quad(0,7]\quad(4,9]\quad(8,10]\quad(14,\infty]\end{aligned}\]</span></p>
<p>这里，第二个观测的事件时间 7 是左删失的，并且该区间的下限为零。最后一个观测 14 是右删失的，该事件时间的上限为无限。则区间边界的有序值为：</p>
<p><span class="math display">\[0\,(L)\quad3\,(L)\quad4\,(L)\quad6\,(U)\quad7\,(U)\quad8\,(L)\quad9\,(U)\quad10\,(U)\quad14\,(L)\quad\infty\,(U)\]</span></p>
<p>有三个 <span class="math inline">\(L\)</span> 后面跟着 <span class="math inline">\(U\)</span> 的时间区间：<span class="math inline">\((4,6],(8,9]\)</span> 和 <span class="math inline">\((14,\infty)\)</span>。这些是生存函数未定义的 Turnbull 区间。请注意，与 Kaplan-Meier 估计一样，对这五个观测，生存函数在超过最长事件时间 14 后是未定义的，因为这是右删失的。</p>
</div>
</div>
<p>为了估计生存函数，假设我们有一个包含 <span class="math inline">\(n\)</span> 个区间删失事件时间的样本，形式为 <span class="math inline">\((l_i,u_i],i=1,2,\ldots,n\)</span>，其中第 <span class="math inline">\(i\)</span> 个区间包括上限 <span class="math inline">\(u_i\)</span>，但不包括下限 <span class="math inline">\(l_i\)</span>。如果第 <span class="math inline">\(i\)</span> 个观测是精确已知的，则 <span class="math inline">\(l_i=u_i\)</span>，而如果它是右删失的，则 <span class="math inline">\(u_i=\infty\)</span>，如果左删失，则 <span class="math inline">\(l_i=0\)</span>。对于一个精确的事件时间，有 <span class="math inline">\(l_i=u_i\)</span>，对应的区间是无穷小的，此时生存函数会出现一个阶跃 (step). 当数据集中的一个区间的下限等于另一个的上限时，这种表示法还消除了识别 Turnbull 区间的任何歧义。这里，在确定 Turnbull 区间时，下限是在上限之后立即出现的时间点，因此下限位于上限之后<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;This notation also resolves any ambiguity in identifying Turnbull intervals when a data set includes intervals where the lower limit of one is the same as the upper limit of another. Here, the lower limit is at a time that is immediately after the upper limit and so is placed after the upper limit when determining Turnbull intervals.&lt;/p&gt;"><sup>8</sup></a>。</p>
<p>生存函数估计在 Turnbull 区间之间是恒定的，并且是从概率 <span class="math inline">\(\theta_j\)</span> 推导出来的，该概率表示事件时间 <span class="math inline">\(t\)</span> 位于 <span class="math inline">\(m\)</span> 个 Turnbull 区间的第 <span class="math inline">\(j\)</span> 个区间内，这 <span class="math inline">\(m\)</span> 个区间记作 <span class="math inline">\((a_j,b_j],j=1,2,\ldots,m\)</span>。<span class="math inline">\(\theta_j\)</span> 的估计 <span class="math inline">\(\hat\theta_j\)</span> 就是如下 <span class="math inline">\(m\)</span> 个联立方程的解</p>
<p><span class="math display" id="eq:9-1">\[\begin{align}
\theta_j&amp;=\frac1n\sum_{i=1}^n\frac{\alpha_{ij}\theta_j}{\sum_{j=1}^m\alpha_{ij}\theta_j}
\tag{9.1}
\end{align}\]</span></p>
<p>其中，如果第 <span class="math inline">\(j\)</span> 个 Turnbull 区间 <span class="math inline">\((a_j , b_j ]\)</span> 包含在第 <span class="math inline">\(i\)</span> 个观测区间 <span class="math inline">\((l_i, u_i], i = 1, 2,...,n\)</span> 中，则 <span class="math inline">\(\alpha_{ij} = 1\)</span>，否则为零。<a href="chap9.html#sec9-2-1">9.2.1</a> 节给出了这一结果的推导过程。</p>
<p>区间删失事件时间样本的生存函数估计在 Turnbull 区间之间是恒定的，而在这些区间内（即生存函数值发生变化的地方）则未定义。因此，对于不在 Turnbull 区间内的 <span class="math inline">\(t\)</span> 值，生存函数估计可以表示为</p>
<p><span class="math display" id="eq:9-2">\[\begin{align}
\hat{S}(t)=\sum_{j:b_j&gt;t}\hat{\theta}_j
\tag{9.2}
\end{align}\]</span></p>
<p>其中求和运算对于所有这样的 <span class="math inline">\(\hat\theta_j\)</span> 进行：其 Turnbull 区间的上限超过 <span class="math inline">\(t\)</span>。该估计由 Turnbull (1976) 得出的，通常称为生存函数的 Turnbull 估计。等价地，对于不在 Turnbull 区间内的 <span class="math inline">\(t\)</span> 值，该估计可以写为</p>
<p><span class="math display">\[\left.\hat{S}(t)=\left\{\begin{array}{ll}1&amp;\text{if }t\leqslant a_1,\\1-\hat{\theta}_1-\hat{\theta}_2-\cdots-\hat{\theta}_j&amp;\text{if }b_j\leqslant t\leqslant a_{j+1},j=1,2,\ldots,m-1,\\0&amp;\text{if }t\geqslant b_m\end{array}\right.\right.\]</span></p>
<div id="sec9-2-1" class="section level3" number="9.2.1">
<h3>
<span class="header-section-number">9.2.1</span> 生存函数估计的推导<a class="anchor" aria-label="anchor" href="#sec9-2-1"><i class="fas fa-link"></i></a>
</h3>
<p>假设我们有包含 <span class="math inline">\(n\)</span> 个区间删失事件时间的样本 <span class="math inline">\((l_i,u_i],i=1,2,\ldots,n\)</span>，时间 <span class="math inline">\(t\)</span> 处的生存函数为 <span class="math inline">\(S(t)\)</span>。由于 <span class="math inline">\(S(l_{{i}})-S(u_{{i}})\)</span> 是第 <span class="math inline">\(i\)</span> 个事件时间包含在区间 <span class="math inline">\((l_i, u_i]\)</span> 中的概率，则 <span class="math inline">\(n\)</span> 个区间删失事件时间的似然函数为</p>
<p><span class="math display" id="eq:9-3">\[\begin{align}
L=\prod_{i=1}^n\left[S(l_i)-S(u_i)\right]
\tag{9.3}
\end{align}\]</span></p>
<p>该似然可用不同的形式来表达。假设每个时间区间的下限和上限按升序排列，给出一组唯一值 <span class="math inline">\(\tau_0,\tau_1,\tau_2,\ldots,\tau_r\)</span>，它们满足</p>
<p><span class="math display">\[\tau_0&lt;\tau_1&lt;\tau_2&lt;\cdots&lt;\tau_{r-1}&lt;\tau_r\]</span></p>
<p>其中 <span class="math inline">\(\tau_0=0,\tau_r=\infty\)</span>。令 <span class="math inline">\(\theta_j\)</span> 是事件时间发生在第 <span class="math inline">\(j\)</span> 个区间 <span class="math inline">\((\tau_{j-1},\tau_{j}]\)</span> 内的概率，从而 <span class="math inline">\(\theta_j=S(\tau_{j-1})-S(\tau_j),j=1,2,\ldots,r\)</span>。</p>
<p>此外，如果第 <span class="math inline">\(j\)</span> 个区间<span class="math inline">\((\tau_{j-1},\tau_{j}]\)</span> 包含在第 <span class="math inline">\(i(i=1,2,\ldots,n)\)</span> 个观测区间 <span class="math inline">\((l_{\boldsymbol{i}},u_{\boldsymbol{i}}]\)</span>，则令 <span class="math inline">\(\alpha_{ij}=1\)</span>，否则为 0. 那么，式 <a href="chap9.html#eq:9-3">(9.3)</a> 中的似然函数可以写为</p>
<p><span class="math display">\[L=\prod_{i=1}^n\left\{\sum_{j=1}^r\alpha_{ij}\theta_j\right\}\]</span></p>
<p>在 <span class="math inline">\(0\leqslant\theta_j\leqslant1\)</span> 和 <span class="math inline">\(\sum_{j=1}^r\theta_j=1\)</span> 的约束下最大化。</p>
<p>相应的对数似然函数为</p>
<p><span class="math display">\[\begin{aligned}\log L=\sum_{i=1}^n\log\left\{\sum_{j=1}^r\alpha_{ij}\theta_j\right\}\end{aligned}\]</span></p>
<p>为对其在 <span class="math inline">\(\sum_{j=1}^r\theta_j=1\)</span> 的约束下最大化，引入了拉格朗日乘子 (Lagrange multiplier) <span class="math inline">\(\lambda\)</span>。即，为对数似然函数添加项 <span class="math inline">\(\lambda(\sum_{j}\theta_{j}-1)\)</span>，得到</p>
<p><span class="math display">\[\begin{aligned}\log L_0=\sum_{i=1}^n\log\left\{\sum_{j=1}^r\alpha_{ij}\theta_j\right\}+\lambda\left(\sum_{j=1}^r\theta_j-1\right)\end{aligned}\]</span></p>
<p>鉴于约束项，这不会改变对数似然函数的值。</p>
<p>对 <span class="math inline">\(\log L_0\)</span> 关于 <span class="math inline">\(\theta_j\)</span> 微分并将导数设为零可得到</p>
<p><span class="math display">\[\begin{aligned}\sum_{i=1}^n\frac{\alpha_{ij}}{\sum_{j=1}^r\alpha_{ij}\theta_j}+\lambda&amp;=0\end{aligned}\]</span></p>
<p>两边同时乘以 <span class="math inline">\(\theta_j\)</span> 得到</p>
<p><span class="math display" id="eq:9-4">\[\begin{align}
\sum_{i=1}^n\frac{\alpha_{ij}\theta_j}{\sum_{j=1}^r\alpha_{ij}\theta_j}+\lambda\theta_j&amp;=0
\tag{9.4}
\end{align}\]</span></p>
<p>对该式两边关于 <span class="math inline">\(j\)</span> 求和并利用 <span class="math inline">\(\sum_{j=1}^r\theta_j=1\)</span> 可得 <span class="math inline">\(\sum_{i=1}^n1+\lambda=0\)</span>，从而 <span class="math inline">\(\lambda = −n\)</span>，再将 <span class="math inline">\(\lambda\)</span> 带回式 <a href="chap9.html#eq:9-4">(9.4)</a>，得到</p>
<p><span class="math display">\[\begin{aligned}\sum_{i=1}^n\frac{\alpha_{ij}\theta_j}{\sum_{j=1}^r\alpha_{ij}\theta_j}-n\theta_j&amp;=0\end{aligned}\]</span></p>
<p>这得到了方程组</p>
<p><span class="math display">\[\begin{aligned}\theta_j&amp;=\frac{1}{n}\sum_{i=1}^n\frac{\alpha_{ij}\theta_j}{\sum_{j=1}^r\alpha_{ij}\theta_j}\end{aligned}\]</span></p>
<p>事实上</p>
<p><span class="math display">\[\frac{\alpha_{ij}\theta_j}{\sum_{j=1}^r\alpha_{ij}\theta_j}\]</span></p>
<p>是位于区间 <span class="math inline">\((l_i, u_i]\)</span> 中的事件时间 <span class="math inline">\(t\)</span> 出现在第 <span class="math inline">\(j\)</span> 个 Turnbull 区间内的概率，令 <span class="math inline">\(\theta_j\)</span> 等于这些值的均值可以得到相同的结果。</p>
<p>由于 <span class="math inline">\(\theta_j\)</span> 仅在 <span class="math inline">\(m\)</span> 个 Turnbull 区间中非零，因此将非零值重新记为 <span class="math inline">\(\theta_1,\theta_2,\ldots,\theta_m\)</span>，因此现在 <span class="math inline">\(\theta_j\)</span> 是事件时间包含在第 <span class="math inline">\(j(j=1,2,\ldots,m)\)</span> 个 Turnbull 区间 <span class="math inline">\((a_j,b_j]\)</span> 中的概率。这是式 <a href="chap9.html#eq:9-1">(9.1)</a> 的结果。</p>
<p>该估计是从似然函数导出的，且无需指定生存时间的概率分布，因此它是非参数最大似然估计 (Non-Parametric Maximum Likelihood Estimator, NPMLE). 此外，该估计过程源于用于获得 <span class="math inline">\(\theta_j\)</span> 的最大似然估计的期望最大化 (EM) 算法。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-3" class="example"><strong>示例 9.3  (人造区间删失数据) </strong></span><br></p>
<p>在本例中，使用<a href="chap9.html#exm:ex9-2">示例 9.2</a> 中的人造数据说明获得生存函数的 Turnbull 估计所需的计算，其中区间为</p>
<p><span class="math display">\[\begin{aligned}(3,6]\quad(0,7]\quad(4,9]\quad(8,10]\quad(14,\infty]\end{aligned}\]</span></p>
<p>在<a href="chap9.html#exm:ex9-2">示例 9.2</a> 中，发现 Turnbull 区间为 <span class="math inline">\((4,6],(8,9]\)</span> 和 <span class="math inline">\((14,\infty)\)</span>，并且生存函数估计在这三个区间之间是恒定的。</p>
<p>表 9.3 给出了区间 <span class="math inline">\((a_j,b_j],j=1,2,\ldots,3\)</span> 的 <span class="math inline">\(\alpha_{ij}\)</span> 值，如果区间 <span class="math inline">\((l_i,u_i]\)</span> 包括 <span class="math inline">\((a_j,b_j]\)</span>，则 <span class="math inline">\(\alpha_{ij}\)</span> 为一，否则为零。非零 <span class="math inline">\(\theta\)</span> 值 <span class="math inline">\(\hat{\theta}_1,\hat{\theta}_2\)</span> 和 <span class="math inline">\(\hat\theta_3\)</span> 所满足的方程可以从式 <a href="chap9.html#eq:9-1">(9.1)</a> 中获得，例如</p>
<p><span class="math display">\[\begin{aligned}
\widehat{\theta}_{1}&amp;=\frac{1}{5}\sum_{i=1}^5\frac{\alpha_{i1}\hat{\theta}_1}{\alpha_{i1}\hat{\theta}_1+\alpha_{i2}\hat{\theta}_2+\alpha_{i3}\hat{\theta}_3} \\
&amp;=\left.\frac15\left\{\frac{\hat{\theta}_1}{\hat{\theta}_1}+\frac{\hat{\theta}_1}{\hat{\theta}_1}+\frac{\hat{\theta}_1}{\hat{\theta}_1+\hat{\theta}_2}\right\}\right.
\end{aligned}\]</span></p>
<p>化简后</p>
<p><span class="math display">\[\begin{aligned}\hat{\theta}_1=\frac{1}{5}\left(\frac{3\hat{\theta}_1+2\hat{\theta}_2}{\hat{\theta}_1+\hat{\theta}_2}\right)\end{aligned}\]</span></p>
<p>类似地</p>
<p><span class="math display">\[\hat\theta_2=\frac{1}{5}\left(\frac{\hat\theta_1+2\hat\theta_2}{\hat\theta_1+\hat\theta_2}\right)\]</span></p>
<p>并且关于 <span class="math inline">\(\hat\theta_3\)</span> 的表达式直接得到 <span class="math inline">\(\hat\theta_3=0.2\)</span>。求解这些方程组后得到 <span class="math inline">\(\hat{\theta}_1=0.5333,\hat\theta_2=0.2667\)</span>，并且 <span class="math inline">\(\hat{\theta}_1,\hat{\theta}_2,\hat{\theta}_3\)</span> 满足约束：和为一。</p>
<p>生存函数的相应估计在 <span class="math inline">\(\hat\theta_j=0\)</span> 的区间上是恒定的，而在 <span class="math inline">\(\hat\theta_j&gt;0\)</span> 的区间上是未定义的。该估计可从式 <a href="chap9.html#eq:9-2">(9.2)</a> 中得出，从而得出</p>
<p><span class="math display">\[\left.\hat{S}(t)=\left\{\begin{array}{ll}1.000&amp;\quad0\leqslant t\leqslant4\\0.478&amp;\quad6\leqslant t\leqslant8\\0.200&amp;\quad9\leqslant t\leqslant14\end{array}\right.\right.\]</span></p>
<p>在 <span class="math inline">\(t=14\)</span> 之后 <span class="math inline">\(\hat S(t)\)</span> 是未定义的。图 9.1 显示了人造数据生存函数的估计。</p>
<details><summary><font color="#8B2232">图 9.1</font>
</summary><img src="figure/figure%209.1.png#center" style="width:80.0%"></details><p><br>
在该图中，阴影部分为 Turnbull 区间，生存函数估计由直线连接，即使它们在这些区间内没有定义。</p>
</div>
</div>
<p>尽管在这个简单的示例中，可以在不使用数值方法的情况下获得 <span class="math inline">\(\theta\)</span> 的估计，但这种情况很少发生。此外，支持估计过程的 EM 算法通常收敛速度很慢。因此，人们提出了替代算法，包括ICM (Iterative Convex Minorant) 算法和 EMICM 算法，EMICM 算法是 ICM 和 EM 算法的组合。此外，不能使用获得生存函数估计的标准误的常用方法。这是因为随着样本量的增加，未知 <span class="math inline">\(\theta\)</span> 参数的数量不可避免地会增加，这意味着附录 <a href="A.html#A">A</a> 的基于似然计算标准误的方法不再适用。相反，基于 bootstrap 的重采样方案被广泛使用。第 6 章 <a href="chap6.html#sec6-1">6.1</a> 节概述了这一过程。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-4" class="example"><strong>示例 9.4  (溃疡复发) </strong></span><br></p>
<p>对于<a href="chap9.html#exm:ex9-1">示例 9.1</a> 中给出的溃疡复发时间数据，生存函数 <span class="math inline">\(S(t)\)</span> 表示任何给定时间 <span class="math inline">\(t\)</span> 后复发的概率。对于两种治疗，生存函数估计 <span class="math inline">\(S(t)\)</span> 在 <span class="math inline">\(t = 0\)</span> 时为 1，在 12 个月后未定义。
对于接受治疗 A 的患者，对于 <span class="math inline">\(2\leqslant t\leqslant 6\)</span>，<span class="math inline">\(\hat S(t)=0.842\)</span>，对于 <span class="math inline">\(t = 12\)</span>，<span class="math inline">\(\hat S(t)=0.777\)</span>；对于接受治疗 B 的患者，对于 <span class="math inline">\(5\leqslant t\leqslant 6\)</span>，<span class="math inline">\(\hat S(t)=0.917\)</span>，对于 <span class="math inline">\(7\leqslant t\leqslant 12\)</span>，<span class="math inline">\(\hat S(t)=0.708\)</span>。生存函数在其他地方没有定义，如图 9.2 所示。</p>
<details><summary><font color="#8B2232">图 9.2</font>
</summary><img src="figure/figure%209.2.png#center" style="width:80.0%"></details><p><br>
这些估计相差不大，表明这两种治疗方法对溃疡复发的时间有相似的效应。通过对区间删失数据进行建模，我们将能够正式检查任何治疗差异的显著性。</p>
</div>
</div>
</div>
</div>
<div id="sec9-3" class="section level2" number="9.3">
<h2>
<span class="header-section-number">9.3</span> 半参数比例风险模型<a class="anchor" aria-label="anchor" href="#sec9-3"><i class="fas fa-link"></i></a>
</h2>
<p>区间删失事件时间数据模型可以评估和总结因素和解释变量对事件时间的影响。与右删失数据一样，模型基于任何给定时间的死亡风险，可以是半参数或全参数的。本节描述半参数比例风险模型，其中不对事件时间的潜在分布做出假设。</p>
<p>在比例风险模型中，第 <span class="math inline">\(i\)</span> 个个体（共 <span class="math inline">\(n\)</span> 个）在时间 <span class="math inline">\(t\)</span> 的死亡风险为</p>
<p><span class="math display">\[h_i(t)=\exp(\boldsymbol{\beta'x}_i)h_0(t)\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{\beta'x}_i\)</span> 是第 <span class="math inline">\(i\)</span> 个个体解释变量值 <span class="math inline">\(\boldsymbol x_i\)</span> 的线性组合，<span class="math inline">\(h_0(t)\)</span> 是基线风险函数。<span class="math inline">\(t\)</span> 时刻对应的生存函数为</p>
<p><span class="math display">\[\begin{aligned}S_i(t)=S_0(t)^{\exp(\boldsymbol{\beta'x}_i)}\end{aligned}\]</span></p>
<p>其中 <span class="math inline">\(S_0(t)\)</span> 是基线风险函数，且 <span class="math inline">\(S_0(0)=1,S_0(\infty)=0\)</span>。</p>
<p>为可能右删失的生存数据拟合 Cox 回归模型包括构建不涉及 <span class="math inline">\(h_0(t)\)</span> 的偏似然函数，并最大化该函数以获得 <span class="math inline">\(\beta\)</span> 参数的估计。对于区间删失数据来说这是不可能的，并且需要根据完全似然函数同时估计 <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(h_0(t)\)</span>。对于形如 <span class="math inline">\((l_i, u_i]\)</span> 的 <span class="math inline">\(n\)</span> 个区间删失事件时间样本，<span class="math inline">\(i = 1, 2,...,n\)</span>，如式 <a href="chap9.html#eq:9-3">(9.3)</a>，全似然函数为</p>
<p><span class="math display" id="eq:9-5">\[\begin{align}
L=\prod_{i=1}^nP(l_i&lt;T\leqslant u_i)=\prod_{i=1}^n\left\{S_i(l_i)-S_i(u_i)\right\}
\tag{9.5}
\end{align}\]</span></p>
<p>右删失时间对该似然的贡献是 <span class="math inline">\(S_i(l_i)\)</span>，左删失时间则为 <span class="math inline">\(1 − S_i(u_i)\)</span>，对于未删失事件时间（<span class="math inline">\(l_i = u_i\)</span>）则为 <span class="math inline">\(f(t_{{i}})=-\mathrm{d}S_{{i}}(t_{{i}})/\mathrm{d}t\)</span>。</p>
<div id="sec9-3-1" class="section level3" number="9.3.1">
<h3>
<span class="header-section-number">9.3.1</span> 半参数 Turnbull 模型<a class="anchor" aria-label="anchor" href="#sec9-3-1"><i class="fas fa-link"></i></a>
</h3>
<p>一种可能的半参数模型是通过将基线生存函数作为基于 Turnbull 区间的 NPMLE 来形成。该模型称为<strong>半参数 Turnbull 模型</strong>，相邻 Turnbull 区间之间的风险、累积风险和生存函数都是恒定的。具体来说，如果一组区间删失事件时间得到 <span class="math inline">\(m\)</span> 个 Turnbull 区间 <span class="math inline">\((a_j,b_j],j=1,2,\ldots,m\)</span>，则 <span class="math inline">\(S_0(t)\)</span> 对于区间 <span class="math inline">\((0,a_1],(b_1,a_2],\ldots,(b_{m-1},a_m],(b_m,\infty]\)</span> 中的 <span class="math inline">\(t\)</span> 值是恒定的。第 <span class="math inline">\(k\)</span> 个这样的区间中 <span class="math inline">\(t\)</span> 值（在两个连续 Turnbull 区间之间的第 <span class="math inline">\(k\)</span> 个区间中的 <span class="math inline">\(t\)</span> 值）的基线生存函数为</p>
<p><span class="math display">\[\begin{aligned}S_0(t)=\zeta_k,\quad k=1,2,\ldots,r\end{aligned}\]</span></p>
<p>第 <span class="math inline">\(k\)</span> 个区间中相应的基线累积风险为 <span class="math inline">\(-\log(\zeta_k)\)</span>，并且风险函数为累积风险的增量。</p>
<p>该模型将生存函数的 NPMLE 推广到区间删失数据的回归模型，类似于右删失数据的 Cox 回归模型。根据式 <a href="chap9.html#eq:9-5">(9.5)</a>，<span class="math inline">\(n\)</span> 个区间删失观测的全似然函数 <span class="math inline">\((l_i,u_i]\)</span> 为</p>
<p><span class="math display" id="eq:9-6">\[\begin{align}
\prod_{i=1}^n\left\{S_0(l_i)^{\exp(\boldsymbol{\beta'x}_i)}-S_0(u_i)^{\exp(\boldsymbol{\beta'x}_i)}\right\}$
\tag{9.6}
\end{align}\]</span></p>
<p>并且通过最大化该似然函数来拟合模型。对于生存函数的 NPMLE，一般采用 EMICM 算法来拟合该模型，拟合过程可在多个软件包中实现。使用 bootstrap 等模拟方法来获得参数估计的标准误，这在第 6 章 <a href="chap6.html#sec6-1">6.1</a> 节中结合分段指数模型进行了描述。虽然右删失数据可以表示为区间删失事件时间，但拟合半参数 Turnbull 模型所得参数估计与拟合 Cox 模型所得参数估计不同。这是因为拟合过程是基于全似然函数而不是偏似然函数。</p>
<p>一旦拟合了模型，可得式 <a href="chap9.html#eq:9-5">(9.5)</a> 对数似然函数的最大值 <span class="math inline">\(\log \hat L\)</span>，那么量 <span class="math inline">\(-2\log\hat{L}\)</span> 可用于以通常的方式比较替代模型。总的来说，将 <span class="math inline">\(-2\log\hat{L}\)</span> 值之差与卡方分布的百分点进行比较，后者自由度等于替代嵌套模型之间 <span class="math inline">\(\beta\)</span> 参数数量之差。对于非嵌套模型，第 3 章 <a href="chap3.html#sec3-6-1">3.6.1</a> 节中描述的 AIC 或 BIC 统计量可用于模型比较。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-5" class="example"><strong>示例 9.5  (溃疡复发) </strong></span><br></p>
<p><a href="chap9.html#exm:ex9-1">示例 9.1</a> 给出的溃疡复发时间数据现在用于说明为区间删失数据拟合半参数 Turnbull 模型。要拟合的模型的基线生存函数在相邻 Turnbull 区间之间保持恒定，因此第一步是确定这些区间。使用表 9.2 将区间删失观测的限按升序排列，得到三个 Turnbull 区间：<span class="math inline">\((0,2],(6,7]\)</span> 和 <span class="math inline">\((12,\infty)\)</span>。这意味着基线生存函数只有两个参数，对应于时间区间 <span class="math inline">\((0,2],(6,7]\)</span>。</p>
<p>拟合包含与 <span class="math inline">\(Age,Duration\)</span> 和 <span class="math inline">\(Treat\)</span>（<a href="chap9.html#exm:ex9-1">示例 9.1</a> 中定义的年龄、持续时间和治疗）对应的变量的模型后，<span class="math inline">\(-2\log\hat{L}\)</span> 统计量的值为 62.566. 单独拟合 <span class="math inline">\(Treat\)</span> 时的相应值为 62.884. 由于 0.32 的差异相对于自由度为二的卡方分布的百分位点非常小，我们得出结论，年龄和治疗持续时间都不会影响这些患者的溃疡复发时间。实际上，零模型的 <span class="math inline">\(-2\log\hat{L}\)</span> 为 62.982，因此没有显著的治疗效应。然而，该项将保留在模型中，以便估计效应的大小。</p>
<p>治疗 B 的患者相对于治疗 A 的患者的对数风险比估计为 0.195，相应的风险比为 1.216. 对数风险比的标准误差是根据 10000 个 bootstrap 样本估计的。这涉及模拟 10000 个数据集，其中每个数据集都是通过从表 9.1 给出的数据中有放回地随机抽取 43 个观测而形成的。然后为每个数据集拟合仅包含 <span class="math inline">\(Treat\)</span> 的半参数 Turnbull 模型，从而对 <span class="math inline">\(Treat\)</span> 的对数风险比进行 10000 次估计。这些值的标准差是标准误的 bootstrap 估计。标准差为 1.488，因此风险比的 95% 置信区间为 <span class="math inline">\(\exp(0.195\pm1.96\times1.488)\)</span>，即 0.066 到 22.442 的区间。据估计，治疗 B 会使溃疡复发的风险增加 22%，但这种差异并不显著，相应的风险比区间估计包括一。</p>
<p>表 9.4 给出了每种治疗的患者的生存函数估计。治疗 A 中患者的生存函数是基线生存函数估计 <span class="math inline">\(\hat S_0(t)\)</span>，并且生存函数在区间 <span class="math inline">\((0,2],(6,7]\)</span> 和超过 12 个月时没有定义。生存函数的差异很小，但确实表明接受 B 治疗的患者溃疡复发的概率略有增加，尽管不显著。</p>
</div>
</div>
</div>
<div id="sec9-3-2" class="section level3" number="9.3.2">
<h3>
<span class="header-section-number">9.3.2</span> 区间删失数据的分段指数模型<a class="anchor" aria-label="anchor" href="#sec9-3-2"><i class="fas fa-link"></i></a>
</h3>
<p>另一种半参数模型假定基线风险函数在多个连续时间区间的每一个内都是恒定的，且与 Turnbull 区间的位置无关。这得到了第 6 章 <a href="chap6.html#sec6-1">6.1</a> 节描述的分段指数模型，对于第 <span class="math inline">\(j(j=1,2,\ldots,r)\)</span> 个时间区间 <span class="math inline">\(t_{(j-1)}\leqslant t&lt;t_{(j)}\)</span> 中的事件时间 <span class="math inline">\(t\)</span>（其中 <span class="math inline">\(t_{(0)}=0\)</span>），有</p>
<p><span class="math display">\[\begin{aligned}h_0(t)=\lambda_j\end{aligned}\]</span></p>
<p>对于右删失数据，可以将区间设置为每个区间内的事件时间数大致相等。然而，对于区间删失数据，由于事件时间本身未观测到，因此无法实现这一点。相反，可以选择具有类似数量的唯一边界值的区间，或者选择覆盖相似时间段的区间。</p>
<p>根据第 6 章方程式 <a href="chap6.html#eq:6-3">(6.3)</a>，相应的基线累积风险函数为</p>
<p><span class="math display" id="eq:9-7">\[\begin{align}
H_0(t)=\sum_{j=1}^r\lambda_j\Delta_j(t)
\tag{9.7}
\end{align}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\left.\Delta_j(t)=\left\{\begin{array}{ll}0&amp;t&lt;t_{(j-1)}\\t-t_{(j-1)}&amp;t_{(j-1)}\leqslant t&lt;t_{(j)}\\t_{(j)}-t_{(j-1)}&amp;t\geqslant t_{(j)}\end{array}\right.\right.\]</span></p>
<p>并且基线生存函数为 <span class="math inline">\(S_0(t)=\exp\{-H_0(t)\}\)</span>。似然函数与式 <a href="chap9.html#eq:9-6">(9.6)</a> 中的似然函数相同，并且在 <span class="math inline">\(h_0(t)\)</span> 中的 <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\lambda\)</span> 参数上最大化。在风险函数的这个公式中，<span class="math inline">\(\lambda_j&gt;0\)</span>，为确保这一点，它通常通过设置 <span class="math inline">\(\phi=\log\lambda\)</span> 来参数化。与往常一样，使用 <span class="math inline">\(-2\log\hat{L}\)</span> 统计量来比较嵌套模型、使用 AIC 或 BIC 统计量来比较非嵌套模型。</p>
<p>该比例风险模型可以扩展，以允许解释变量系数在所选时间区间之间不同。这两个模型 <span class="math inline">\(-2\log\hat{L}\)</span> 值之差得到了比例风险检验。</p>
<p>尽管可以使用第 3 章 <a href="chap3.html#sec3-3-3">3.3.3</a> 节描述的 Newton-Raphson 程序为区间删失数据拟合分段指数模型，但更常用的是更高效的方法，如 EMCM 算法。然而，由于生存函数估计在 Turnbull 区间内是未定义的，因此基于与这些时间区间重叠的时间区间的估计可能不是唯一的。当区间数相对较小时，附录 <a href="A.html#A">A</a> 中总结的似然法可得到参数估计的标准误，尽管也可以使用 bootstrap 法。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-6" class="example"><strong>示例 9.6  (溃疡复发) </strong></span><br></p>
<p>在本示例中，为<a href="chap9.html#exm:ex9-1">示例 9.1</a> 中首次给出的溃疡复发时间的数据拟合分段指数模型。由于检测溃疡复发的内镜检查计划在初次治疗后 6 个月和 12 个月进行，因此在分段指数模型中使用时间区间 <span class="math inline">\((0,6]\)</span> 和 <span class="math inline">\((6,12]\)</span> 是很自然的。因此，基线风险函数对于 <span class="math inline">\(0\leqslant t&lt;6\)</span> 为 <span class="math inline">\(\lambda_1\)</span>，对于 <span class="math inline">\(6\leqslant t&lt;12\)</span> 为 <span class="math inline">\(\lambda_2\)</span>。使用 <span class="math inline">\(Age,Duration\)</span> 和 <span class="math inline">\(Treat\)</span> 这三项拟合分段指数比例风险模型后，<span class="math inline">\(-2\log\hat{L}=73.889\)</span>，省略 <span class="math inline">\(Age,Duration\)</span> 后，该量增加为 74.258. 该模型中 <span class="math inline">\(Treat\)</span> 的系数估计为 0.209，因此治疗 B 相对于治疗 A 复发的风险为 1.232，95% 置信区间为 0.360 到 4.213. 该区间包含一，再次指出不存在显著的治疗效应。在两个区间中，基线风险函数中的参数估计分别为 <span class="math inline">\(\hat{\lambda}_1=0.018\)</span> 和 <span class="math inline">\(\hat{\lambda}_2=0.028\)</span>。使用式 <a href="chap9.html#eq:9-7">(9.7)</a> 可得出累积风险函数的相应估计，即</p>
<p><span class="math display">\[\left.\hat{H}_0(t)=\left\{\begin{array}{ll}\hat{\lambda}_1t&amp;\quad0\leqslant t&lt;6\\\hat{\lambda}_2t+6(\hat{\lambda}_1-\hat{\lambda}_2)&amp;\quad6\leqslant t&lt;12\\6(\hat{\lambda}_1+\hat{\lambda}_2)&amp;\quad t\geqslant12\end{array}\right.\right.\]</span></p>
<p>那么基线生存函数估计为 <span class="math inline">\(\hat{S}_0(t)=\exp\{-\hat{H}_0(t)\}\)</span>。治疗 A 和治疗 B 患者的生存函数估计如图 9.3 所示。</p>
<details><summary><font color="#8B2232">图 9.3</font>
</summary><img src="figure/figure%209.3.png#center" style="width:80.0%"></details><p><br>
对于接受治疗 A 的患者，生存函数估计再次稍大，这表明该组溃疡复发的时间较长。<a href="chap9.html#exm:ex9-5">示例 9.5</a> 中单独使用 <span class="math inline">\(Treat\)</span> 拟合的半参数模型以及本示例中的分段指数模型都具有三个未知参数，这两个模型的 AIC 统计量的值分别为 68.884 和 80.258. 因此，半参数 Turnbull 对观测数据拟合得更好。</p>
<p>将模型扩展为在每个时间区间内具有不同的治疗效应，模型变为</p>
<p><span class="math display">\[\left.h_i(t)=\left\{\begin{array}{ll}\exp(\beta_1x_i)\lambda_1&amp;\quad0\leqslant t&lt;6\\\exp(\beta_2x_i)\lambda_2&amp;\quad6\leqslant t&lt;12\end{array}\right.\right.\]</span></p>
<p>其中，若第 <span class="math inline">\(i\)</span> 个患者接受治疗 A，则 <span class="math inline">\(x_i = 0\)</span>，否则为 <span class="math inline">\(1\)</span>. 拟合此模型后，<span class="math inline">\(-2\log\hat{L}=71.821\)</span>，因此与在每个时间区间内具有不同治疗效应相关的 <span class="math inline">\(-2\log\hat{L}\)</span> 的减小量在一个自由度上为 2.437，<span class="math inline">\(P =0.119\)</span>。治疗 B 相比治疗 A 的风险比估计在第一个区间中为 0.415，在第二个区间中为 3.459. 尽管这种差异仅在 12% 的水平上显著，但有迹象表明，在溃疡初次治疗后 6 至 12 个月内，（相比前 6 个月）治疗效应更大。</p>
</div>
</div>
</div>
</div>
<div id="sec9-4" class="section level2" number="9.4">
<h2>
<span class="header-section-number">9.4</span> 参数模型<a class="anchor" aria-label="anchor" href="#sec9-4"><i class="fas fa-link"></i></a>
</h2>
<p>上一节描述的半参数模型得到了对风险和生存函数的不连续估计，这在实际中是不现实的。然而，可以使用第 <a href="chap5.html#chap5">5</a> 章和第 <a href="chap6.html#chap6">6</a> 章描述的全参数模型来获得这些函数的平滑估计。为区间删失数据拟合这些模型也是很简单的。</p>
<p>在全参数比例风险模型中，第 <span class="math inline">\(i(i=1,2,\ldots,n)\)</span> 个个体的风险和生存函数为</p>
<p><span class="math display">\[\begin{aligned}h_i(t)=\exp(\boldsymbol{\beta'x}_i)h_0(t),\quad S_i(t)=S_0(t)^{\exp(\boldsymbol{\beta'x}_i)}\end{aligned}\]</span></p>
<p>其中，<span class="math inline">\(\boldsymbol x_i\)</span> 是 <span class="math inline">\(p\)</span> 个解释变量的值向量，<span class="math inline">\(h_0(t),S_0(t)\)</span> 是 <span class="math inline">\(\boldsymbol x_i\)</span> 分量均为零的基线风险和生存函数。对于第 5 章 <a href="chap5.html#sec5-6">5.6</a> 节所述的 Weibull 比例风险模型，<span class="math inline">\(h_0(t)=\lambda\gamma t^{{\gamma}-1}\)</span> 和 <span class="math inline">\(S_0(t)=\exp(-\lambda t^\gamma)\)</span>。通过最大化式 <a href="chap9.html#eq:9-6">(9.6)</a> 给出的似然函数，可以为 <span class="math inline">\(n\)</span> 个区间删失事件时间 <span class="math inline">\(l_i,u_i],i=1,2,\ldots,n\)</span> 拟合该模型。对于 Weibull 模型，这是</p>
<p><span class="math display" id="eq:9-8">\[\begin{align}
L=\prod_{i=1}^n\left\{[\exp(-\lambda l_i^\gamma)]^{\exp(\boldsymbol{\beta}^\prime\boldsymbol{x}_i)}-[\exp(-\lambda u_i^\gamma)]^{\exp(\boldsymbol{\beta}^\prime\boldsymbol{x}_i)}\right\}
\tag{9.8}
\end{align}\]</span></p>
<p>并且可以使用数值方法（如第 3 章 <a href="chap3.html#sec3-3-3">3.3.3</a> 节描述的 Newton-Raphson 程序）来得到 <span class="math inline">\(\hat{\boldsymbol\beta},\hat\lambda\)</span> 和 <span class="math inline">\(\hat\gamma\)</span>。使用附录 <a href="A.html#A">A</a> 中的结果可得到参数估计的标准误。在拟合模型下，将最大似然函数的值记作 <span class="math inline">\(\hat L\)</span>，可以使用统计量 <span class="math inline">\(-2\log\hat{L}\)</span> 来比较替代嵌套模型。</p>
<p>加速失效时间模型，也在第 5 章中描述，允许拟合具有许多事件时间分布的模型，包括 Weibull 模型。一般加速失效时间模型有</p>
<p><span class="math display">\[\begin{aligned}\log T_i=\mu+\alpha'\mathbf{x}_i+\sigma\epsilon_i\end{aligned}\]</span></p>
<p>其中 <span class="math inline">\(\epsilon_i\)</span> 的分布使得 <span class="math inline">\(T_i\)</span> 呈 Weibull, log-logistic 或 log-normal 分布，<span class="math inline">\(\alpha\)</span> 参数是模型中解释变量的系数，<span class="math inline">\(\mu,\sigma\)</span> 是位置和尺度参数。<span class="math inline">\(n\)</span> 个区间删失事件时间的似然函数再次由式 <a href="chap9.html#eq:9-5">(9.5)</a> 给出，其中，使用式 <a href="chap5.html#eq:5-56">(5.56)</a></p>
<p><span class="math display">\[\begin{aligned}S_i(t)=S_{\epsilon_i}\left(\frac{\operatorname{log}t-\mu-\alpha_1x_{1i}-\alpha_2x_{2i}-\cdots-\alpha_px_{pi}}{\sigma}\right)\end{aligned}\]</span></p>
<p><span class="math inline">\(t\)</span> 取值 <span class="math inline">\(l_i\)</span> 和 <span class="math inline">\(u_i\)</span>。函数 <span class="math inline">\(S_{\epsilon_i}(\cdot)\)</span> 对应于所选的事件时间分布。对于 Weibull 加速失效时间模型，<span class="math inline">\(S_{\epsilon_i}(\epsilon)=\exp(-e^{\epsilon})\)</span>，所得似然函数等价于式 <a href="chap9.html#eq:9-8">(9.8)</a> 中的似然函数，其中对于 <span class="math inline">\(j=1,2,\ldots,p\)</span></p>
<p><span class="math display">\[\begin{aligned}\lambda=\exp(-\mu/\sigma),\quad\gamma=\sigma^{-1},\quad\beta_j=-\alpha_j/\sigma\end{aligned}\]</span></p>
<p>第 5 章 <a href="%E5%8F%82%E6%95%B0%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.html#sec5-11">5.11</a> 节给出了完整的详细信息。</p>
<p>这些加速失效时间模型是通过最大化以 <span class="math inline">\(\boldsymbol{\alpha},{\mu}\)</span> 和 <span class="math inline">\(\sigma\)</span> 为参数的似然函数来拟合的，并使用 <span class="math inline">\(-2\log\hat{L}\)</span> 统计量比较替代嵌套模型。AIC 统计量可用于比较非嵌套模型，例如具有不同事件时间分布的模型。参数模型的一个缺点是，在假定的分布模型中，风险和生存函数取决于相对较少的未知参数，这可能很难用区间删失数据进行验证。然而，更灵活的模型，如对数累积基线风险函数的 Royston and Parmar 限制性立方样条模型，可以克服这一问题。<a href="chap6.html#sec6-4">6.4</a> 节描述的模型的似然函数很容易使用式 <a href="chap9.html#eq:9-5">(9.5)</a> 获得，并且在拟合和比较替代的 Royston and Parmar 模型时不涉及新的原理。</p>
<div class="rmdnote">
<div class="example">
<p><span id="exm:ex9-7" class="example"><strong>示例 9.7  (溃疡复发) </strong></span><br></p>
<p>本实例说明为溃疡复发时间的区间删失数据拟合 Weibull 比例风险模型。包含与 <span class="math inline">\(Age,Duration\)</span> 和 <span class="math inline">\(Treat\)</span> （对应于年龄、持续时间和治疗）对应的变量的 Weibull 模型的 <span class="math inline">\(-2\log\hat{L}=74.291\)</span>，省略 <span class="math inline">\(Age\)</span> 和 <span class="math inline">\(Duration\)</span> 后，导致在两个自由度上增加 0.334. <span class="math inline">\(-2\log\hat{L}\)</span> 的这种非显著变化意味着患者年龄和治疗持续时间对这组患者的溃疡复发时间都没有显著影响，如<a href="chap9.html#exm:ex9-5">示例 9.5</a> 和 <a href="chap9.html#exm:ex9-6">9.6</a> 所示。治疗 B 相对于治疗 A 的风险比为 1.251，这再次与在<a href="chap9.html#exm:ex9-5">示例 9.5</a> 和 <a href="chap9.html#exm:ex9-6">9.6</a> 的替代模型下发现的风险比非常相似。然而，这与一没有显著差异，因为当从模型中省略治疗项时，<span class="math inline">\(-2\log\hat{L}\)</span> 统计量仅从 74.625 增加到 74.754.</p>
<p>在模型的加速失效时间参数化中，时间比为 <span class="math inline">\(e^{-0.258}=0.773\)</span>，这意味着治疗 B 将复发时间乘以 0.773. 接受治疗 B 的患者的复发时间估计约为接受治疗 A 的患者的 77%，因此治疗 B 有效地加快了导致溃疡复发的过程。</p>
</div>
</div>
</div>
<div id="sec9-5" class="section level2" number="9.5">
<h2>
<span class="header-section-number">9.5</span> 延伸阅读<a class="anchor" aria-label="anchor" href="#sec9-5"><i class="fas fa-link"></i></a>
</h2>
<p>Sun (2006) 一书全面介绍了分析区间删失事件时间的统计模型和方法。Bogaerts, Komarek and Lesaffre (2018) 提供了使用 R, SAS 和 BUGS 分析生存数据的实用介绍。另请参阅 Chen, Sun and Peace (2013), Lindsey and Ryan (1998), Lesaffre, Komárek and Declerck (2005), Gómez et al. (2009) 以及 Zhang and Sun (2010) 提供了有关此类数据分析方法的综述文章。Jewell and van der Laan (2004) 回顾了当前状态数据的分析方法，并描述了竞争风险和多变量生存数据的扩展。</p>
<p>Turnbull (1976) 引入了所谓的 Turnbull 区间，并描述了一种用于根据区间删失数据估计生存函数的自洽算法。EM 算法由 Dempster, Laird and Rubin (1977) 描述，Groeneboom and Wellner (1992) 引入了 Iterative Convex Minorant (ICM) 算法。Wellner and Zahn (1997) 提出使用 EM 和 ICM 算法的组合。Wang et al. (2016) 提出使用样条函数来近似累积基线风险函数。Pan (1999) 展示了如何使用 ICM 算法来拟合比例风险模型。Zeng, Mao and Lin (2016) 展示了如何使用 EM 算法来拟合具有时依变量的比例风险和比例几率半参数模型。</p>
<p>Sun (2001) 描述了在右删失数据中获取生存函数标准误的 Greenwood 公式如何扩展到区间删失数据，并且还描述了当基于似然的方法失效时如何使用 bootstrap 方法。Goodall, Dunn and Babiker (2004) 描述了三种方法，用于计算根据区间删失数据估计的非参数生存函数的逐点置信区间。</p>
<p>许多作者已经讨论了区间删失数据的分段指数模型中分割点的位置。其中包括 Finkelstein (1986)，他建议每个区间内的预期事件数相似；Cai and Betensky (2003) 描述了一种使用唯一区间端点分位数的方法。</p>
<p>第 <a href="chap2.html#chap2">2</a> 章描述了用于比较两组或多组右删失生存时间的一些非参数检验。类似于 log-rank 和 Wilcoxon 检验的检验统计量很容易构建，但数据的区间性质意味着更难获得这些程序的方差和渐近性质。Finkelstein (1986) 提出了一种得分检验，而 Sun (1996), Zhao and Sun (2004) 将 log-rank 检验推广到区间删失数据。Fay (1996) 提出了比例几率模型下的一个检验，并描述了用于比较区间删失数据的生存函数的统一框架。Fay and Shaw (2010) 还总结了加权 log-rank 检验（如 log-rank 检验和 Wilcoxon 检验）对区间删失数据的推广，描述了实现它们的 R 包。Huang, Lee and Yu (2008) 描述了多重插补检验。</p>
<p>Lindsey (1998) 回顾了参数模型在区间删失数据分析中的应用。Farrington (2000) 提供了与区间删失数据的比例风险模型一起使用的诊断方法的全面说明。Zhang et al. (2007) 考虑了在存在信息删失时对区间删失数据的分析。</p>

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="chap8.html"><span class="header-section-number">8</span> 时依变量</a></div>
<div class="next"><a href="chap10.html"><span class="header-section-number">10</span> 脆弱模型</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#chap9"><span class="header-section-number">9</span> 区间删失生存数据</a></li>
<li>
<a class="nav-link" href="#sec9-1"><span class="header-section-number">9.1</span> 区间删失</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#sec9-1-1"><span class="header-section-number">9.1.1</span> 当前状态数据</a></li></ul>
</li>
<li>
<a class="nav-link" href="#sec9-2"><span class="header-section-number">9.2</span> 估计生存函数</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#sec9-2-1"><span class="header-section-number">9.2.1</span> 生存函数估计的推导</a></li></ul>
</li>
<li>
<a class="nav-link" href="#sec9-3"><span class="header-section-number">9.3</span> 半参数比例风险模型</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#sec9-3-1"><span class="header-section-number">9.3.1</span> 半参数 Turnbull 模型</a></li>
<li><a class="nav-link" href="#sec9-3-2"><span class="header-section-number">9.3.2</span> 区间删失数据的分段指数模型</a></li>
</ul>
</li>
<li><a class="nav-link" href="#sec9-4"><span class="header-section-number">9.4</span> 参数模型</a></li>
<li><a class="nav-link" href="#sec9-5"><span class="header-section-number">9.5</span> 延伸阅读</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>医学研究中的生存数据建模</strong>" was written by Wang Zhen. It was last built on 2024-04-23.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
